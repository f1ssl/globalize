# Globalize 1.3.0 announcement

Today we are releasing Globalize 1.3.0. It is a special release, because it includes some very useful enhancements and therefore we wanted to get a bit more verbose about them.

## IANA/Olson Time Zone Support

> This change was contributed by Ramalingam Manikandan @rajavelmani (PayPal) and Rafael Xavier @rxaviers in #687 and #701.

Globalize already had some partial time zone support, which means it was constrained to the user's runtime time zone and it was impossible to display certain CLDR patterns (`z`, `v`, and `V`) that display strings such as `PDT`,  `Pacific Daylight Time`, `Pacific Time`, and `Los Angeles Time`. The concern [we had](https://github.com/globalizejs/globalize/pull/202) was how costly a solution to provide full IANA/Olson time zone support would be due to the additional manipulation code and extra data (i.e., IANA database). Therefore, we used to encourage users that needed to manipulate date in arbitrary time zones to use a separate library, like *moment-timezone*. Nevertheless, such suggestion never closed the gap between doing a great job at i18n leveraging CLDR and have full control over time zone.

Now, Globalize 1.3.0 fully supports IANA/Olson time zone. So, basically using Globalize you have full time zone support with the strength of CLDR for i18n.

```js
Globalize.locale("en");
let date = new Date();

Globalize.formatDate(date, {datetime: "short", timeZone: "America/Los_Angeles"});
// > '3/19/17, 3:19 PM'
Globalize.formatDate(date, {datetime: "short", timeZone: "America/New_York"});
// > '3/19/17, 6:19 PM'
Globalize.formatDate(date, {datetime: "short", timeZone: "America/Sao_Paulo"});
// > '3/19/17, 7:19 PM'
Globalize.formatDate(date, {datetime: "short", timeZone: "Europe/Berlin"});
// > '3/19/17, 11:19 PM'

Globalize.formatDate(date, {datetime: "full", timeZone: "America/Los_Angeles"});
// > 'Sunday, March 19, 2017 at 3:19:22 PM Pacific Daylight Time'
Globalize.formatDate(date, {datetime: "full", timeZone: "America/New_York"});
// > 'Sunday, March 19, 2017 at 6:19:22 PM Eastern Daylight Time'
Globalize.formatDate(date, {datetime: "full", timeZone: "America/Sao_Paulo"});
// > 'Sunday, March 19, 2017 at 7:19:22 PM Brasilia Standard Time'
Globalize.formatDate(date, {datetime: "full", timeZone: "Europe/Berlin"});
// > 'Sunday, March 19, 2017 at 11:19:22 PM Central European Standard Time'

Globalize("pt").formatDate(date, {datetime: "full", timeZone: "America/Sao_Paulo"});
// > 'domingo, 19 de março de 2017 19:19:22 Horário Padrão de Brasília'
Globalize("de").formatDate(date, {datetime: "full", timeZone: "Europe/Berlin"});
// > 'Sonntag, 19. März 2017 um 23:19:22 Mitteleuropäische Normalzeit'
Globalize("zh").formatDate(date, {datetime: "full", timeZone: "Asia/Shanghai"});
// > '2017年3月20日星期一 中国标准时间 上午6:19:22'
Globalize("ar").formatDate(date, {datetime: "full", timeZone: "Africa/Cairo"});
// > 'الاثنين، ٢٠ مارس، ٢٠١٧ ١٢:١٩:٢٢ ص توقيت شرق أوروبا الرسمي'
```

We believe to have solved this in a lighweight manner by using [zoned-date-time](https://github.com/rxaviers/zoned-date-time) under the hoods, which is a 0.6KB library for the time zone manipulations, and by leveraging the Globalize Compiler for precompling the IANA data base for production. For example, let's say you are serving content in English for *America/Los_Angeles* time using the following formatter:

```js
var dateWithTimeZoneFormatter = Globalize.dateFormatter({
  datetime: "full",
  timeZone: "America/Los_Angeles"
});
```

The final size (for production) of this code will be:

| filename                                 | minified+gzipped size |
| ---------------------------------------- | --------------------- |
| i18n/en.js (includes CLDR and IANA data) | 1.7KB                 |
| core, number, and date globalize runtime lib + zoned-date-time | 7.0KB                 |

See globalize [compiler example](https://github.com/globalizejs/globalize/tree/master/examples/globalize-compiler) or [app-npm-webpack example](https://github.com/globalizejs/globalize/tree/master/examples/app-npm-webpack) for details.

## Format Date To Parts

> This change was contributed by Reza Payami @rpayami (PayPal) and Rafael Xavier @rxaviers in #697 and #700.

Modern user interfaces often need to manipulate the date format output, which is impossible via the existing format function that returns an opaque string and makes any attempt to do it subject to break internationalization. [Ecma-402](https://github.com/tc39/ecma402/) has recently added [`Intl.DateTimeFormat.prototype.formatToParts`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts) to fulfill that purpose, which at the time of this writing is at stage 4 and is implemented by latest Firefox and Chrome.

In Globalize, we introduced [`.dateToPartsFormatter`](https://github.com/globalizejs/globalize/blob/master/doc/api/date/date-to-parts-formatter.md) and [`.formatDateToParts`](https://github.com/globalizejs/globalize/blob/master/doc/api/date/date-to-parts-formatter.md).

```js
Globalize.locale( "en" );
Globalize.formatDateToParts(new Date(2010, 10, 30));
// > [
//   { "type": "month", "value": "11" },
//   { "type": "literal", "value": "/" },
//   { "type": "day", "value": "30" },
//   { "type": "literal", "value": "/" },
//   { "type": "year", "value": "2010" }
// ]
```

The information is made available separately and it can be formatted and concatenated again in a customized way. For example by using [`Array.prototype.map()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map), [arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), a [switch statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch), [template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals), and [`Array.prototype.reduce()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).

```js
let formatter;

Globalize.locale( "en" );
formatter = Globalize.dateToPartsFormatter({datetime: "short"});

formatter( new Date( 2010, 10, 30, 17, 55 ) ).map(({type, value}) => {
  switch ( type ) {
    case "year": return `<strong>${value}</strong>`;
    default: return value;
  }
}).join( "" );
// > "11/30/<strong>10</strong>, 5:55 PM"
```

See [React Date Input](https://github.com/rxaviers/react-date-input) as a demo of a UI component for React optimized for i18n and a11y.

| Localized and smart date input           | Feb 28 in `en`, `es`, `pt`, `de`, `zh`, `ko`, and `ar` |
| ---------------------------------------- | ---------------------------------------- |
| ![en](https://media.giphy.com/media/xUA7aZAUNINGP2jI4M/giphy.gif) | ![en-es-pt-de-zh-ko-ar](https://media.giphy.com/media/3og0ILQu0KxLRewJnW/giphy.gif) |

## Dynamically Augment Date Skeletons

> This change was contributed by Marat Dyatko @vectart and Artur Eshenbrener @Strate in #462 and #604.

The style used to display a date format often vary depending on the application. CLDR offers data for certain presets like short, medium, long, and full date (time and datetime) and it also offers data for a lot of different [date fields](http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table) and their combinations, which are used by globalize to sintetize an open-ended list of custom formats (called skeletons). But, what's interesting is that it would be prohibitively large if CLDR provided data for every single possible combination. So, there's an algorithm specified by UTS#35 to deduce missing data from the requested format.

For example, there are four different presets to format a date and they would generate `"7/1/17"` (short), `"Jul 1, 2017"` (medium), `"July 1, 2017"` (long), and `"Saturday, July 1, 2017"` (full). Although, let's pretend we want something different such as `"Jul 1"`. For that format we could use `{skeleton: "MMMd"}`. Internally, globalize finds a direct match (in CLDR) for that skeleton. Let's now pretend we want `"July 1"`. For that format we could use `{skeleton: "MMMMd"}`. Internally, globalize doesn't find a direct match (in CLDR) for this skeleton and it needs to use the data for `MMMd`, which in the case of English maps to `"MMM d"`, and then replace `MMM` with `MMMM` dynamically generating `"MMMM d"`. If we wanted `"07/01"` instead, we could use `{skeleton: "MMdd"}`. Internally, globalize doesn't find a direct match in CLDR for this skeleton and it needs to use the data for `Md`, which in the case of English maps to `"M/d"`, and then replace `M` wtih `MM` and `d` with `dd` dynamically generating `"MM/dd"`.

To make long a story short, the algorithm in globalize 1.3.0 has been significantly improved (it's almost in full conformance with UTS#35) and it allows one to be very imaginative about inventing skeletons.

```js
let skeleton = "GyMMMMEEEEdhms";
Globalize("en").formatDate(new Date(), {skeleton});
// > 'Saturday, July 1, 2017 AD at 4:58:27 PM'
Globalize("pt").formatDate(new Date(), {skeleton});
// > 'sábado, 1 de julho de 2017 d.C. 5:01:20 PM'
Globalize("de").formatDate(new Date(), {skeleton});
// > 'Samstag, 1. Juli 2017 n. Chr. um 5:01:33 nachm.'
Globalize("zh").formatDate(new Date(), {skeleton});
// > '公元2017年七月月1日星期六 下午5:01:35'
Globalize("ko").formatDate(new Date(), {skeleton});
// > 'AD 2017년 7월 1일 토요일 오후 5:01:38'
Globalize("ar").formatDate(new Date(), {skeleton});
// > 'السبت، ١ يوليو، ٢٠١٧ م ٥:٠١:٤٠ م'
Globalize("ar-MA").formatDate(new Date(), {skeleton});
// > 'السبت، 1 يوليوز، 2017 م 5:04:29 م'
Globalize("it").formatDate(new Date(), {skeleton});
// > 'sabato 1 luglio 2017 d.C. 5:01:52 PM'
```

Read our [getting started](https://github.com/globalizejs/globalize/#getting-started) and play with it yourself.

## Other Enhancements and Bug Fixes

🎉 Enhancements

- Date: Show timezone offset optional minutes for O pattern (e.g., GMT-6:30 note the :30) #339 (via PR #729) (Rafael Xavier)
- Date: Show timezone offset optional minutes and seconds for x and X patterns (e.g., -06:30 note the :30) #339 (via PR #729) (Rafael Xavier)
- Date: Assert options.skeleton (PR #726) (Rafael Xavier)
- Date parser: Make runtime phase lighter #735 (Rafael Xavier)
- Date parser: Loose Matching PR #730 (Rafael Xavier)
- - Allows, among others, parsing arabic dates as user types them (i.e., without control characters)
- Runtime: Use strict #676

🐛 Fixes

- Date parser: invalid output by mixing numbering systems #696 (via PR #733) (Rafael Xavier)
- Date parser: fails on Turkish full datetime with Monday or Saturday #690 (via PR #732) (Rafael Xavier)

⚙️ Others

- Compiler tests! #721 (via PR #727) (Nikola Kovacs)
- Documentation style refactor #737 (Rafael Xavier)